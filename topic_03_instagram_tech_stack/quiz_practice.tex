\documentclass[10pt]{article}

\usepackage[margin=1in]{geometry}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\usepackage[shortlabels]{enumitem}
\usepackage[normalem]{ulem}
\usepackage{courier}

\usepackage{hyperref}
\hypersetup{
  colorlinks   = true, %Colours links instead of ugly boxes
  urlcolor     = black, %Colour for external hyperlinks
  linkcolor    = blue, %Colour of internal links
  citecolor    = blue  %Colour of citations
}

\usepackage[T1]{fontenc}
\usepackage{upquote}
\usepackage{listings}
\lstset{
    language=HTML
    ,basicstyle=\linespread{1}\ttfamily
    ,keywordstyle=
    ,language=sh
    ,showstringspaces=false
    ,numbers=left
    ,breaklines=true
    }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newtheorem{note}{Note}
\newcommand{\E}{\mathbb E}
\newcommand{\R}{\mathbb R}
\DeclareMathOperator{\Var}{Var}
\DeclareMathOperator*{\argmin}{arg\,min}
\DeclareMathOperator*{\argmax}{arg\,max}

\newcommand{\trans}[1]{{#1}^{T}}
\newcommand{\loss}{\ell}
\newcommand{\w}{\mathbf w}
\newcommand{\mle}[1]{\hat{#1}_{\textit{mle}}}
\newcommand{\map}[1]{\hat{#1}_{\textit{map}}}
\newcommand{\normal}{\mathcal{N}}
\newcommand{\x}{\mathbf x}
\newcommand{\y}{\mathbf y}
\newcommand{\ltwo}[1]{\lVert {#1} \rVert}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\begin{center}
    {
\Large
    Quiz: POSIX Shell III (Practice Problems)
}

    \vspace{0.1in}
\end{center}

\section{Glob}

\begin{note}
    The POSIX shell has a built-in pattern matching feature for working with files.
    The glob operator \lstinline{*} matches zero or more of any character,
    and the question operator \lstinline{?} matches exactly one of any character.
    The \lstinline{*} and \lstinline{?} operators do not match a dot at the beginning of the file, and so do not match hidden files.
\end{note}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch hello world
$ touch hola mundo 
$ touch salve munde
$ rm *e*
$ ls | wc -l
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch hello world
$ touch hola mundo 
$ touch salve munde
$ rm e*
$ ls | wc -l
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch hello world
$ touch hola mundo 
$ touch salve munde
$ rm *e
$ ls | wc -l
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch .hello world
$ touch .hola mundo 
$ touch .salve munde
$ rm *e*
$ ls -a | wc -l
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch .hello world
$ touch .hola mundo 
$ touch .salve munde
$ rm .*e
$ ls -a | wc -l
\end{lstlisting}
\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch "hello world"
$ touch "hola mundo"
$ touch "salve munde"
$ rm *d?
$ ls | wc -l
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch "hello world"
$ touch "hola mundo"
$ touch "salve munde"
$ rm *d?
$ ls | wc -l
\end{lstlisting}

\subsection{Weirdness}
\begin{note}
    The glob does not expand within quotes.
    If the glob expression has no matches,
    then the literal expression is passed as an argument.
\end{note}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch "hello world"
$ touch "hola mundo"
$ touch "salve munde"
$ touch *
$ ls | wc -l
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch *
$ ls | wc -l
\end{lstlisting}
\filbreak


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch *
$ ls | wc -l
\end{lstlisting}
\filbreak


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch "hello world"
$ touch "hola mundo"
$ touch "salve munde"
$ touch "*"
$ ls | wc -l
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch "hello world"
$ touch "hola mundo"
$ touch "salve munde"
$ touch "*"
$ ls | wc -l
\end{lstlisting}


\subsection{For loops}
\begin{note}
    Glob expansion happens after the shell processes the spaces that separate the list of strings to loop over.
\end{note}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch "hello world"
$ touch "hola mundo"
$ touch "salve munde"
$ for i in *; do echo $i; done | wc -l
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch hello world
$ touch hola mundo
$ touch salve munde
$ for i in *; do echo $i; done | wc -l
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ touch hello world
$ touch hola mundo
$ touch salve munde
$ for i in "*"; do echo $i; done | wc -l
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ for i in *; do echo $i; done | wc -l
\end{lstlisting}

\filbreak
\subsection{Security}

\begin{note}
    Glob expansion happens in the shell,
    before the parameters are sent to the program.
    This can have unintended side effects.
    If you are working in a directory where someone else is allowed to create files,
    they can create files that will be expanded by \lstinline{*} into command line arguments.
    This problem can be mitigated by using \lstinline{./*} instead of \lstinline{*}.
    Command line arguments that appear after a \lstinline{--} will never be interpreted as command line arguments.
\end{note}

\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir test
$ rm *
$ ls
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir test
$ echo evil > -rf
$ rm *
$ ls
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir test
$ echo evil > -rf
$ rm ./*
$ ls
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir test
$ rm -- -rf *
$ ls
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir test
$ rm -rf -- *
$ ls
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir -- -a
$ echo evil > -a/evil
$ ls *
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ mkdir -- -a
$ echo evil > -a/evil
$ ls -- *
\end{lstlisting}

\filbreak
\section{Fun with git and glob}

\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ git init
$ touch hello world
$ touch .salve .munde
$ git add *e*
$ git commit -m 'first commit'
$ git checkout -b foo
$ git add *
$ git commit -m 'second commit'
$ git checkout master
$ git checkout -b bar
$ git add .
$ git commit -m 'third commit'
$ git checkout master
$ ls -a
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ git init
$ touch hello world
$ touch .salve .munde
$ git add .
$ git commit -m 'first commit'
$ git checkout -b foo
$ touch '*'
$ git add *
$ git commit -m 'second commit'
$ git checkout master
$ git checkout -b bar
$ echo "help me" > test
$ git add *
$ git commit -m 'third commit'
$ git checkout foo
$ ls -a
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ git init
$ mkdir test
$ touch test/hello world
$ touch test/.salve .munde
$ cd test
$ git add .*
$ git commit -m 'first commit'
$ git checkout -b foo
$ git add .
$ git commit -m 'second commit'
$ git checkout master
$ ls -a
\end{lstlisting}


\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ git init
$ mkdir test
$ touch hola mundo
$ touch test/'hello world'
$ touch test/'.salve .munde'
$ cd test
$ for i in *; do git add $i; done
$ git commit -m 'first commit'
$ git checkout -b foo
$ git add .
$ git commit -m 'second commit'
$ ls -a
\end{lstlisting}

\filbreak
\begin{problem}
    Write the output of the final command in the following terminal session.
    If the command has no output, then leave the problem blank.
\end{problem}
\begin{lstlisting}
$ cd; rm -rf quiz; mkdir quiz; cd quiz
$ git init
$ echo evil > -a
$ touch hola mundo
$ touch test/'hello world'
$ touch test/'.salve .munde'
$ cd test
$ git add .
$ git commit -m 'first commit'
$ git checkout -b foo
$ git add ..
$ git commit -m 'second commit'
$ cd $HOME/quiz
$ git checkout master
$ ls *
\end{lstlisting}
\end{document}
